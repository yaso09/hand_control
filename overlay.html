<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<title>Hand Overlay</title>

<style>
body {
  margin: 0;
  background: transparent;
  overflow: hidden;
}

#cursor {
  position: fixed;
  width: 18px;
  height: 18px;
  background: #00ff88;
  border-radius: 50%;
  box-shadow: 0 0 15px #00ff88;
  pointer-events: none;
  transform: translate(-50%, -50%);
}

#cam {
  position: fixed;
  right: 16px;
  bottom: 16px;
  width: 220px;
  opacity: 0.4;
  border-radius: 12px;
  transform: scaleX(-1);
}
</style>
</head>

<body>

<div id="cursor"></div>
<video id="cam" autoplay muted playsinline></video>

<script src="./node_modules/@mediapipe/hands/hands.js"></script>
<script src="./node_modules/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
const cam = document.getElementById("cam");
const cursor = document.getElementById("cursor");

/* ===== SETTINGS ===== */
let settings = {
  opacity: 100,
  sensitivity: 1.0,
  hand: "left",
  enableMove: true,
  enableClick: true,
  enableRightClick: true,
  enableScroll: true,
  autoStart: true
};

// Ayarları yükle
function loadSettings() {
  const saved = localStorage.getItem("handControlSettings");
  if (saved) settings = { ...settings, ...JSON.parse(saved) };
  applySettings();
}

function applySettings() {
  cursor.style.opacity = settings.opacity / 100;
}

// IPC settings update
window.electronAPI?.ipcRenderer?.on?.("settings-updated", (_, newSettings) => {
  settings = { ...settings, ...newSettings };
  localStorage.setItem("handControlSettings", JSON.stringify(settings));
  applySettings();
});

/* ===== STATE ===== */
let cursorX = screen.width / 2;
let cursorY = screen.height / 2;
let smoothX = cursorX;
let smoothY = cursorY;

let anchor = null;
let lastMove = { x: cursorX, y: cursorY };

let fistActive = false;
let scrollAnchor = null;
let scrollMode = false;

/* pinch */
let pinchActive = false;
let pinchStartTime = null;

/* ===== PARAMS ===== */
const SMOOTHING = 0.15;
const GAIN = 2.8;
const RIGHT_CLICK_THRESHOLD = 550;
const SCROLL_GAIN = 0.6;
const SCROLL_DEADZONE = 10;

/* ===== CAMERA ===== */
navigator.mediaDevices.getUserMedia({ video: true })
  .then(s => cam.srcObject = s);

/* ===== MEDIAPIPE ===== */
const hands = new Hands({
  locateFile: f =>
    new URL(`./node_modules/@mediapipe/hands/${f}`, location.href).toString()
});

hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 0,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
});

/* ===== HELPERS ===== */
const smooth = (t, c) => c + (t - c) * SMOOTHING;

const isPinch = lm =>
  Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.045;

const isFist = lm => {
  const tips = [8,12,16,20];
  const base = [5,9,13,17];
  return tips.filter((t,i)=>lm[t].y>lm[base[i]].y).length>=3;
};

const isClutch = lm => lm[4].y < lm[3].y && !isFist(lm);

/* ===== CORE LOOP ===== */
hands.onResults(res => {
  if (!res.multiHandLandmarks || !res.multiHandedness) return;

  let left=null, right=null;

  res.multiHandLandmarks.forEach((lm,i)=>{
    const side=res.multiHandedness[i].label;
    if(side==="Left") left=lm;
    if(side==="Right") right=lm;
  });

  let cursorHand = settings.hand==="left" ? right : left;
  let actionHand = settings.hand==="left" ? left : right;

  /* CURSOR */
  if (cursorHand) {
    const hx = 1 - cursorHand[8].x;
    const hy = cursorHand[8].y;

    if (isClutch(cursorHand)) {
      if (!scrollMode) {
        scrollMode = true;
        scrollAnchor = { y: hy };
      }
      return;
    }

    scrollMode = false;

    if (!anchor) {
      anchor = { x: hx, y: hy };
      return;
    }

    const dx = (hx - anchor.x) * screen.width;
    const dy = (hy - anchor.y) * screen.height;

    if (settings.enableMove) {
      cursorX += dx * GAIN * settings.sensitivity;
      cursorY += dy * GAIN * settings.sensitivity;

      cursorX = Math.max(0, Math.min(screen.width, cursorX));
      cursorY = Math.max(0, Math.min(screen.height, cursorY));

      smoothX = smooth(cursorX, smoothX);
      smoothY = smooth(cursorY, smoothY);

      cursor.style.left = smoothX + "px";
      cursor.style.top  = smoothY + "px";

      lastMove = { x: smoothX, y: smoothY };
    }

    anchor = { x: hx, y: hy };
  }

  /* ACTION */
  if (actionHand) {

    const pinch = isPinch(actionHand);

    if (pinch && !pinchActive) {
      pinchActive = true;
      pinchStartTime = performance.now();
    }

    if (!pinch && pinchActive) {
      const duration = performance.now() - pinchStartTime;

      window.ipc.send("mouse-move", lastMove.x, lastMove.y);
      window.ipc.send(
        duration > RIGHT_CLICK_THRESHOLD ? "mouse-right-click" : "mouse-click"
      );

      pinchActive = false;
      pinchStartTime = null;
    }

    const fist = isFist(actionHand);

    if (fist && !fistActive) {
      fistActive = true;
      scrollAnchor = { y: actionHand[8].y };
    }

    if (fist && scrollAnchor) {
      const deltaY = (scrollAnchor.y - actionHand[8].y) * screen.height * 2;
      if (Math.abs(deltaY) > SCROLL_DEADZONE && settings.enableScroll) {
        window.ipc.send("mouse-scroll", deltaY * SCROLL_GAIN);
        scrollAnchor.y = actionHand[8].y;
      }
    }

    if (!fist) {
      fistActive = false;
      scrollAnchor = null;
    }
  }
});

/* CAMERA LOOP */
setTimeout(() => {
  new Camera(cam, {
    onFrame: async () => hands.send({ image: cam }),
    width: 640,
    height: 480
  }).start();
}, 300);

loadSettings();
</script>
</body>
</html>
